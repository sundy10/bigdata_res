package chapter14

object scala09_handle_more_List extends App {

  /**
   * 14.9 同时处理多个列表
   *
   * 你已经见过列表的zip方法，这个方法根据两个列表创建一个新的由对偶组成的列表，让你能够同时对两个列表进行操作:
   */
  println(List(10, 20).zip(List(3, 4, 5)).map { (x, y) => x * y })

  /**
   * @注意
   *
   * 最终的map方法利用了Scala 3的名称为参数反元组化(parameter untupling）的特性:
   * 当某个带有两个或更多参数的函数字面量的预期类型是一个接收单个元组参数的函数时，其参数将被自动反元组化。例如，在前一个表达式中的map方法调用等同于map{case (x,y)=>x * y)}。
   */

  /**
   * 对两个被zip在一起的列表执行map方法将对 成对的元素(而不是单个元素）进行映射。
   * 两个列表的第一个元素组成第一对，第二个元素组成第二对，以此类推，列表有多长，就有多少对。
   * 注意，第二个列表的第三个元素被丢弃了。因为zip方法只会把所有列表中都有值的元素zip在一起，所以多出来的元素会被丢弃。
   *
   * @通过zip方法对多个列表进行操作的一个弊端是（在zip方法被调用时）会创建最终（在map方法被调用时）被丢弃的中间列表。如果列表中有很多元素，则创建中间列表可能意味着很大的成本开销。
   */

  /**
   * @lazyZip方法可以解决这个问题，它的语法与zip方法很像:
   */
  println(List(10, 20).lazyZip(List(3, 4, 5)).map(_ * _))

  /**
   * lazyZip和zip方法的区别在于lazyZip方法并不立即返回集合（因此才有lazy前缀)，
   * 而是返回一个提供了对两个“懒”zip在一起的列表执行操作（包括map操作)的值。
   * 在上面的例子中，可以看到map方法接收一个函数作为参数，而这个函数接收两个参数（而不是一个对偶)，允许我们使用占位符语法。
   */

  /**
   * @同样地,exists和口forall方法也有针对“懒”版本的zip实现。它们与单列表版本做的事情相同，只不过它们操作的是多个列表而不是一个:
   */
  println(List("abc","de").lazyZip(List(3,2)).forall(_.length==_) )//true
  println(List("abc","de").lazyZip(List(3,2)).exists(_.length==_) )//false

  /**
   * @快速通道
   *
   * 在本章的下一节（也是最后一节)，我们将介绍Scala的类型推断算法的原理。如果你目前对于这样的细节并不关心，则可以跳过下一节，直接进入结语。
   *
   */
}
