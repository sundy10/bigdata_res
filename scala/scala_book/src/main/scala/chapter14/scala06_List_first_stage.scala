package chapter14

object scala06_List_first_stage extends App {

  /**
   * 14.6 List 类的初阶方法
   *
   * 本节将会介绍定义在List类里的大部分初阶方法。
   *
   * @如果一个方法不接收任何函数作为入参，就被称为初阶(first-order）方法。
   * 我们还将通过两个例子来介绍如何组织操作列表的程序的一些技巧。
   */

  /**
   * @拼接两个列表
   *
   * 与:操作相以的一个操作是拼接，写作:::。不同于::，:::接收两个列表参数作为操作元。XS .: ys的结果是一个包含了xs所有元素，以及ys所有元素的新列表。
   */

  println(List(1, 2) ::: List(3, 4, 5))
  println(List() ::: List(3, 4, 5))
  println(List(1, 2, 3) ::: List(4))

  /**
   * @与cons类似，列表的拼接操作也是右结合的。像这样一个表达式:
   */
  List(1, 2) ::: List(3) ::: List(4)
  val xs = List(1,2,3)
  val ys = List(2)
  val zs = List(3)
  //会被解读为
  xs ::: (ys ::: zs)


  /**
   * 分治（(Divide and Conquer）原则
   *
   * 拼接（:::）是作为List类的一个方法实现的。我们也可以通过对列表进行模式匹配来“手工”实现拼接。
   * 建议你自己做一下尝试，因为这个过程展示了用列表实现算法的常用方式。
   * 首先，明确一下拼接方法（我们叫它append）的签名。为了不把事情弄得过于复杂，假设append方法是在List类之外定义的，这样它就需要接收两个待拼接的列表作为参数。
   * 这两个列表必须有相同的元素类型，但这个类型具体是什么并不重要。可以给append方法指定一个代表两个列表的元素类型的类型参数来表达这层意思:
   * (第18章将会有更多关于类型参数的细节讲解。)
   */
  //def append[T](xs:List[T],ys:List[T]):List[T]

  /**
   * @要设计这样一个append方法，有必要回顾一下对于列表这样的递归数据结构的“分而治之”的程序设计原则。
   * 许多对列表的算法都会首先用模式匹配将输入的列表切分成更小的样例。这是设计原则中“分”的部分。
   * 然后对每个样例构建对应的结果。
   * 如果结果是一个非空的列表，则这个列表的局部可以通过递归地调用同一个算法来构建。这是设计原则中“治”的部分。
   *
   * 把这个设计原则应用到append方法的实现中，我们要问的第一个问题是匹配哪一个列表。
   * 与其他方法相比,append方法并不简单，因为我们有两个选择。
   * 好在后续的“治”的部分告诉我们需要同时包含两个输入列表的所有元素。由于列表是从后向前构建的，因此ys可以保持不动，而xs则需要被解开然后被追加到ys的前面。
   * 这样一来，我们有理由选择xs作为模式匹配的来源。匹配列表最常见的模式是区分空列表和非空列表。于是我们可以得到如下append方法的轮廓:
   *
   * 接下来要做的就是填充由???标出的两处。第一处是当输入列表xs为空时的可选分支。这个case中的拼接操作可以直接交出第二个列表
   * 第二处是当输入列表xs由某个头x和尾xs1组成时的可选分支。这个case的结果也是一个非空列表。
   * 要构建一个非空列表，需要知道这个非空列表的头和尾分别是什么。我们已经知道结果的第一个元素是x，而余下的元素可以通过第二个列表ys拼接在第一个列表的剩余部分（即xs1）之后。
   * 这样就得到了完整的设计:
   */

  def append[T](xs: List[T], ys: List[T]): List[T] =
    xs match
      case List() => ys
      case x :: xs1 => x :: append(xs1, ys)

  println(append(List(1, 2, 3), List(4, 5, 6)))

  /**
   * @获取列表的长度:length方法
   * length方法用于计算列表的长度。
   */

  println(List(1, 2, 3).length)

  /**
   * @与数组相比，在列表上的length操作更耗资源。找到一个列表的末尾需要遍历整个列表，因此需要消耗与元素数量成正比的时间。
   * @这也是为什么说将xs.isEmpty这样的测试换成xs.length==0并不是一个好主意。
   * @这两种测试的结果并没有区别，但第二种测试的速度会更慢，尤其是当列表xs很长的时候。
   * @访问列表的末端:init和last方法
   *
   * 我们已经知道基本方法head和tail，它们分别用于获取列表的首个元素和除首个元素之外剩余的部分。
   * 它们也分别对应一个对偶(dual）方法:last方法用于返回（非空)列表的最后一个元素;
   * 而init方法用于返回除最后一个元素之外剩余的部分:
   */

  val abcde = List('a', 'b', 'c', 'd', 'e')
  println(abcde.last)
  println(abcde.init)

  /**
   * headtail方法一样，这两个方法在应用空列表的时候也会抛出异常:
   */
  //List().init
  //Nil.init

  /**
   * @不像head和tail方法那样在运行的时候消耗常量时间，init和last方法需要遍历整个列表来计算结果。因此它们的耗时与列表的长度成正比。
   * @最好将数据组织成大多数访问都发生在列表头部而不是尾部。
   */

  /**
   * @反转列表:reverse方法
   * @如果在算法中的某个点需要频繁地访问列表的末尾，则有时候先将列表反转，再对反转后的列表做操作是更好的做法。下面是一个反转的例子:
   */
  println(abcde.reverse)

  /**
   * 与所有其他列表操作方法一样,reverse方法会创建一个新的列表，而不是对传入的列表做修改。
   * 由于列表是不可变的，因此这样的修改就算我们想做也做不到。
   * 我们现在来验证一下，在进行反转操作后，abcde的原始值是否的确没有发生改变:
   *
   * reverse、init和last方法满足一些可以用于对计算过程推理，以及让程序变得简化的法则。
   * reverse是自己的反转:
   */
  //xs.reverse.reverse =xs

  /**
   * reverse将init变成tail，将last变成head，只不过元素顺序是颠倒的:
   */

  /**
   * 反转操作也可以用拼接（:::）来实现，就像下面这个rev方法:
   */
  def rev[T](xs: List[T]): List[T] =
    xs match {
      case List() => xs
      case x :: xs1 => rev(xs1) ::: List(x)
    }

  /**
   * @不过，这个方法的效率并不高。我们不妨来看一下rev方法的时间复杂度，
   * @假设xs列表长度为n。注意，会有n次对rev方法的递归调用。除最后一次之外，
   * 每次调用都会做列表拼接。xs ::: ys这样的列表拼接所需要的时间与首个入参xs的长度成正比。因此,rev方法的时间复杂度为:
   *
   * n+(n-1)+...+1=(1+n)*n/2
   * 换句话说，rev方法的时间复杂度是入参长度的平方阶。
   * 这与时间复杂度为线性的可变链表的标准反转操作比起来很令人失望。
   * 不过，rev方法当前的实现还能做得更好。在309页开始的例子中，你将看到如何提高这个方法的执行速度。
   */

  /**
   * 前缀和后缀:drop、take和splitAt方法
   *
   * drop和take方法是对tail和init方法的一般化。
   * 怎么说呢?它们返回的是列表任意长度的后缀或前缀。
   * 表达式“xs take n”返回列表xs的前n个元素。如果n大于xs.length，就返回整个xs列表。
   * 操作“xs drop n”返回列表xs除前n个元素之外的所有元素。如果n大于或等于xs.length，就返回空列表。
   *
   * splitAt方法将列表从指定的下标位置切开，返回这两个列表组成的对偶。R它的定义来自如下这个等式:
   *
   * xs.splitAt(n) = (xs.take(n),xs.drop(n))
   * (正如我们在10.12节指出的，对偶是Tuple2的非正式名称。)
   *
   * 不过, splitAt方法会避免遍历两次xs列表。下面是这3个方法的—些例子:
   */

  println(abcde.take(2))
  println(abcde.drop(2))
  println("---")
  println(abcde.splitAt(2))

  /**
   * 元素选择: apply和indices方法
   *
   *        @apply方法支持从任意位置选取元素。不过相对于数组而言，对列表的这项操作并不是那么常用。
   */
  println(abcde.apply(2))

  /**
   * 与其他类型—样,当对象出现在方法调用中函数出现的位置时，编译器会帮助我们插入apply方法。因此上面的代码可以简化为:
   */
  println(abcde(2))

  /**
   *      @对列表而言，从任意位置选取元素的操作之所以不那么常用，是因为xs(n)的耗时与下标n成正比。事实上，apply是通过drop和head方法定义的:
   *
   *      x.apply(n) = (xs.drop(n).head)
   *
   * 从这个定义中也可以清晰地看到，列表的下标从0开始，直到列表长度减1为止，
   *
   * @与数组一样。Indices方法返回包含了指定列表所有有效下标的列表:
   */
  println(abcde.indices) //Range 0 until 5


  /**
   * 扁平化列表的列表:flatten方法
   *    flatten方法接收一个列表的列表并将它扁平化，返回单个列表:
   */
  println(List(List(1,2),List(3),List(),List(5,6)).flatten)

  val fruit = "apples" :: ("oranges" :: ("pears" :: Nil))
  println(fruit.map(_.toList).flatten)

  /**
   * 这个方法只能被应用于那些所有元素都是列表的列表。如果我们尝试将它应用到不满足这个要求的列表，则会得到一个编译错误:
   */
  //List(1,2,3).flatten

  /**
   * @将列表zip起来:zip和unzip方法
   *    zip方法接收两个列表，返回一个由对偶组成的列表:
   *     如果两个列表的长度不同，则任何没有配对成功的元素将被丢弃:
   */
  println(abcde.indices.zip(abcde))
  println(abcde.zip(List(1,2,3)))

  /**
   * @一个有用的特例是将列表和它的下标zip起来。
   * 最高效的做法是使用zipWthIndex方法，这个方法会将列表中的每个元素和它出现在列表中的位置组合成对偶。
   */
  println(abcde.zipWithIndex)

  println(abcde.zipWithIndex.unzip)//(List(a, b, c, d, e),List(0, 1, 2, 3, 4))

  /**
   * zip和unzip方法提供了一种方式让我们可以同时对多个列表进行操作。16.9节还会讲到另一种更精简的方式。
   */

  /**
   * @显示列表:toString和mkString方法
   *
   * toString方法返回列表的标准字符串表现形式:
   * 如果需要不同的表现形式，则可以使用mkString方法。
   * xs.mkString (pre, sep, post)涉及4个操作元:要显示的列表xs、出现在最前面的前缀字符串pre、在元素间显示的分隔字符串sep，以及出现在最后面的后缀字符串post。
   * 这个操作的结果是如下的字符串:
   *
   * mkString方法有两个重载的变种，让我们不必填写部分或全部入参。
   *    第一个变种只接收一个分隔字符串:
   */
  //xs.mkString(sep) =xs.mkString("",sep,"" )
  //xs.mkString=(xs.mkString(""))


  /**
   * mkString方法还有其他的变种，如addString，这个方法可以将构建出来的字符串追加到一个StringBuilder对象上，@而不是作为结果返回:
   */
  val buf = new StringBuilder
  println(abcde.addString(buf,"(",";",")"))

  /**
   * mkString和addString这两个方法继承自List类的超特质Iterable,因此它们也可以被用在所有其他集合类型上。
   */

  /**
   * @转换列表:iterator、toArray和copyToArray方法
   *
   * 为了在扁平的数组世界和递归的列表世界之间进行数据转换，可以使用List类的toArray方法和Array类的toList方法:
   */
  val arr = abcde.toArray;   //Array(a,b,c,d,e)
  arr.toList                 //List(a,b,c,d,e)

  /**
   * 还有一个copyToArray方法可以  将  列表中的元素  依次复制到  目标数组的  指定位置。例如，如下操作:
   */
  private val array: Array[Int] = Array(9)
  println(xs.copyToArray(array,start = 2))
  println(array.toBuffer)

  /**
   * 可以将列表xs的所有元素复制到数组arr，从下标start开始。我们必须确保目标数组足够大，能够容纳整个列表。参考下面的例子:
   */
  private val arr2 = new Array[Int](10)
  List(1,2,3).copyToArray(arr2,3)
  println(arr2.toBuffer)

  /**
   * 最后，如果要通过迭代器访问列表元素，则可以使用iterator方法:
   */
  val it = abcde.iterator

  /**
   * 例子：归并排序
   *
   *  之前介绍的插入排序写起来很简洁，不过效率并不是很高。
   *      @它的平均复杂度与输入列表的长度的平方值成正比。更高效的算法是归并排序( merge sort)。
   */

  /**
   * @快速通道
   *
   * 这个例子是对分治原则和柯里化的另一次展示，同时用来探讨算法复杂度的问题。不过，如果你想在初读本书时更快完成阅读，则可以安心地跳到14.7节。
   *
   * 归并排序的机制如下:首先，如果列表有零个或一个元素，则它已经是排好序的，因此列表可以被直接返回。
   * 更长一些的列表会被切分成两个子列表，每个子列表各含约一半原列表的元素。每个子列表被递归地调用同一个函数来排序，然后两个排好序的子列表会通过一次归并操作合在一起。
   *
   * 要实现一个通用的归并排序实现，应当允许被排序列表的元素类型和用来比较元素大小的函数是灵活可变的。通过参数将这两项作为参数传入，就得到了最灵活的函数。最终的实现参考示例14.2。
   *
   * msort函数的复杂度为order(n log(n))，其中n为输入列表的长度。要弄清楚为什么，要注意需将列表切分成两个子列表，并将两个排好序的列表归并到一起，这两种操作消耗的时间都与列表长度成正比。
   * 每次对msort函数的递归调用都会将输入的元素数量减半，因此差不多需要log(n)次连续的递归调用，直到到达长度为1的列表这个基本case。
   * 不过，对更长的列表而言，每次调用都会进一步生成两次调用。所有这些加在一起，在log(n)次的调用中，原始列表的每个元素都会参与一次切分操作和一次归并操作。
   */



}
