package chapter24

import scala.collection.immutable.Queue

object scala07_immtable extends App {

  /**
   * 24.7 具体的不可变集合类
   *
   * Scala提供了许多具体的不可变集合类供我们选择。它们实现的特质各不相同（映射、集、序列)，
   * 可以是无限的也可以是有限的，且不同的操作有不同的性能表现。我们将从最常见的不可变集合类型开始讲。
   */

  /**
   * @列表(List)
   *
   * 列表是有限的不可变序列。
   * @它提供常量时间的对首个元素和余下元素的访问，以及常量时间的在列表头部添加新元素的操作。
   * 其他的许多操作都是线性时间的。关于列表的详细讨论请参考第14章。
   */

  /**
   * @惰性列表(LazyList)
   * @惰性列表是元素进行惰性求值获得的列表。只有被请求的元素会被计算。因此，惰性列表可以是无限长的。
   * 除此之外，惰性列表的特征与列表一样。
   *
   * 列表通过::操作符来构造，而惰性列表则是通过看上去有些相似的#:操作符来构造的。
   * 这里有一个包含整数1、2和3的惰性列表的示例:
   */
  val str = 1 #:: 2 #:: 3 #:: LazyList.empty
  println(str.toString())

  /**
   * 这个流的头部是1，尾部包括2和3。这里并没有打印出任何元素的值，因为它们都还没有被计算出来。
   * 惰性列表的要求是惰性计算，因此它的toString方法并不会强制任何额外的求值计算。
   *
   * 下面是一个更复杂的例子。这个惰性列表包含一个从给定的两个数字开始的Fibonacci序列。
   * Fibonacci序列的定义是每个元素都是序列中其前面两个元素之和:
   */
  def fibFrom(a: Int, b: Int): LazyList[Int] =
    a #:: fibFrom(b, a + b)

  /**
   * 这个函数看上去实在是简单到可疑。序列的首个元素很显然是a,
   * 而序列余下的部分是从b和a+b开始的Fibonacci序列。最关键的部分是在计算序列的同时不引发无限递归。
   * 如果该函数使用了::操作符而不是#:操作符，则每次对该函数的调用都会引发另一个调用，这样就会造成无限递归。
   *
   * @不过由于它用的是#:操作符，因此表达式的右侧只有在被请求时才会被求值。
   */
  val fibs = fibFrom(1, 1).take(7)
  println(fibs.toList)

  /**
   * @不可变数组序列(ArraySeq)
   *
   * 如果你使用的算法只对列表头部进行处理，则列表是非常高效的(数据结构)。访问、添加和移除列表的头部（元素)只需要常量时间。
   * 不过，如果要对列表中更深的元素进行访问或修改，则所需要的时间与元素在列表中的深度线性相关。
   * 因此，对那些不仅仅处理序列头部元素的算法而言，列表可能并不是最佳选择。
   *
   * 不可变数组序列是一个不可变的序列类型，其背后由一个私有的数组支持，以解决列表随机访问效率不高的问题。
   * 不可变数组序列允许以常量时间访问集合中的任何元素。这样一来，你就不需要担心是不是只能访问不可变数组序列的头部这个问题了。
   * 由于可以以常量时间访问任意位置的元素，因此对某些算法而言，不可变数组序列可以更高效。
   * @另一方面，由于不可变数组序列背后是一个数组，因此向其头部追加元素需要线性时间，而不是像列表那样的常量时间。
   * 不仅如此，任何对不可变数组序列添加或更新单个元素的都需要线性时间，因为整个底层数组都需要被复制。
   */


  /**
   * @向量(Vector)
   *
   * 列表和不可变数组序列对某些场景而言是很高效的数据结构，而对另一些场景而言则不是。
   * 例如，对列表添加头部元素只需要常量时间，而对数组序列添加头部元素需要线性时间。
   * 反过来，对数组序列的下标访问需要常量时间，而对列表的下标访问则需要线性时间。
   *
   * 向量对所有操作都是供了良好的性能。对向量的任何元素的访问都消耗“从实效上讲的常量时间”，稍后会有详细定义。
   * 这个常量时间比访问列表头部或从数组序列中读取某个元素的常量时间要长，不过即便如此，它也是一个常量。
   * 这样一来，使用向量的算法不需要对尽量只访问序列头部这一点格外小心。
   * 它可以访问和修改任意位置的元素，因此编写起来要方便得多。
   *
   * 向量的构建和修改与其他序列并没有什么不同:
   */

  val vec = scala.collection.immutable.Vector.empty
  val vec2 = vec :+ 1 :+ 2 //尾部添加
  println(vec2)
  val vec3 = 100 +: vec2 //头部添加
  println(vec3)

  /**
   * 向量的内部结构是宽而浅的树。树的每个节点包含多达32个元素或32个其他树节点。
   * 小于或等于32个元素的向量可以用单个节点表示。小于或等于32×32 =1024个元素的向量可以通过单次额外的间接性（ indirection）来做到。
   * 如果我们允许从树的根部到最终的元素节点有两跳(hop)，就可以表示多达215个元素的向量;如果允许有3跳，就可以表示多达220个元素的向量;
   * 如果允许有4跳，就可以表示多达225个元素的向量;如果允许有5跳，就可以表示多达230个元素的向量。
   * 因此，对于所有正常大小的向量，选择一个元素只需要最多5次基本的数组操作。这就是我们所说的元素访问消耗“从实效上讲的常量时间”。
   *
   * 由于向量是不可变的，因此你不能当场修改向量元素的值。不过，使用updated方法可以创建一个与给定向量在单个元素上有差别的新向量:
   */
  val vecOld = Vector(1, 2, 3)
  vecOld.updated(2, 4) //Vector(1,2,4)

  /**
   * 如最后一行所示，对updated方法的调用并不会对原始的向量vecOld有任何作用。与选择操作一样，函数式向量的更新也是消耗“从实效上讲的常量时间”。
   * 更新向量中的某个元素可以通过复制包含该元素的节点，以及从根部开始所有指向该节点的节点来完成。
   * 这意味着一次函数式的更新只会创建出1～5个节点，其中每个节点包含32个元素或子树。
   * 当然，这与一次可变数组的当场更新相比开销要大得多，但比起复制整个向量来说，开销还是要小得多。
   *
   * 由于向量在快速的任意位置的选择和快速的任意位置的函数式更新之间达到了较好的平衡，
   * 因此它目前是不可变的带下标索引的序列的默认实现(Seq的默认实现是List)
   */

  /**
   * @不可变队列
   *
   * 队列是一个先进先出的序列。在第18章中，我们探讨了一个不可变队列的简化实现。下面是演示如何创建一个空的不可变队列的例子:
   */
  val empty = scala.collection.immutable.Queue[Int]()
  //可以用enqueue方法来为不可变队列追加一个元素:
  val has1: Queue[Int] = empty.enqueue(1) //Queue(1)

  //要追加多个元素，可以用一个集合作为入参来调用enqueueAlI方法:
  val has123: Queue[Int] = has1.enqueueAll(List(2, 3)) //Queue(1,2,3)

  //要从列表头部移除元素，可以用dequeue方法:
  val (element, has23) = has123.dequeue
  println(element)
  println(has23)

  /**
   * 注意，dequeue方法返回的是一组包含被移除的元素及队列剩余部分的对偶(Tuple2)。
   */


  /**
   * @区间
   * @区间是一个有序的整数序列，整数之间有相同的间隔。
   * 举例来说，“1,2,3”是区间，“5,8,11,14”也是区间。用Scala创建区间的方式是使用预定义的方法to和by。这里有一些例子:
   */
  println(1 to 3)
  println(5 to 14 by 3)

  /**
   * 如果你要创建的区间不包含上限，则可以用until方法而不是to方法:
   *
   * @区间的内部表示占据常量的空间，因为它可以用3个数表示:起始值、终值和步长。因此，大多数区间操作者都非常快。
   */
  println(1 until 3)


  /**
   * @经过压缩的哈希数组映射的前缀树
   *
   * 哈希字典树(hash trie)是实现高效的不可变集和不可变映射的标准方式。
   * 而经过压缩的哈希数组映射的前缀树(compressedhash-array mapped prefix-tree）是哈希字典树在JVM上的一种设计，
   * (Steindorfer等，《优化哈希数组映射的字典树以实现快速而紧凑的不可变JVM集合》。)
   * 提升了局部性，并且能够确保其树状结构保持规整而紧凑。它的内部表现形式与向量类似，
   * 也是每个节点有32个元素或32棵子树的树，不过元素选择是基于哈希码的。
   * 举例来说，要找到映射中给定的键，首先用键的哈希码的最低5位找到第一棵子树，然后用接下来的5位找到第二棵子树，
   * 以此类推。当某个节点的所有元素的哈希码（已用到的部分)各不相同时，这个选择过程就停止了。因此我们并不是必须用到哈希码的所有位的。
   *
   *
   * 哈希字典树在比较快的查找和比较高效的函数式插入（+）及删除(-)之间找到了一个不错的平衡。
   * 这也是为什么说它们是Scala对不可变映射和不可变集的默认实现基础。
   * 事实上，Scala对于包含元素少于5个的不可变集和不可变映射还有更进一步的优化方法。
   * 带有1~4个元素的集和映射都被存放在只是通过字段包含这些元素（(对映射而言是键/值对）的单个对象中。
   * 空的不可变集和空的不可变映射也分别都是单例对象（我们并不需要对空集或空映射进行重复存储，因为空的不可变集或映射永远都是空的)。
   */

  /**
   * @红黑树
   *
   * 红黑树（red-black tree）是一种平衡的二叉树，其中某些节点被标记为“红”的而其他节点被标记为“黑”的。
   * @与其他平衡二叉树一样，对它的操作可以可靠地在与树规模相关的对数时间内完成。
   *
   * Scala提供了内部使用红黑树的集和映射的实现。你可以用TreeSet和TreeMap来访问它们:
   */
  val set = collection.immutable.TreeSet.empty[Int]
  println(set + 1 + 3 + 3)

  /**
   * 红黑树也是Scala中SortedSet的标准实现，
   *
   * @因为它提供了按顺序返回集的所有元素的一个高效的迭代器。
   */


  /**
   * @不可变位组(BitSet)
   *
   * 位组( bit set)是用来表示 某个更大整数的位的小整数的集合。
   * 例如，包含3、2和O的位组可以用二进制的整数1101表示，转换或十进制就是13。
   *
   * 从内部来讲，位组使用的是一个64位Long(长整数）的数组，
   * 数组中第一个Long表示0～63的整数，第二个Long表示64~127的整数，以此类推。
   * 因此，只要位组中最大的整数小于百这个规模，位组就会非常紧凑。
   *
   * 对位组的操作非常快。测试某个位组是否包含某个值只需要常量时间。
   * 向 位组添加条目需要的时间与位组的Long数组长度成正比，这通常是一个很小的值。下面是一些使用位组的简单例子:
   */
  val bits = scala.collection.immutable.BitSet.empty
  val moreBits = bits + 3 + 4 + 5
  println(moreBits.size)

  /**
   * @向量映射(VectorMap)
   *
   * 向量映射是一个同时使用Vector（表示键)和HashMap的映射。它提供了一个可以按照插入顺序返回所有条目的迭代器。
   */

  import scala.collection.immutable.VectorMap

  val vm = VectorMap.empty[Int, String]
  val vm1 = vm + (1 -> "one")
  val vm2 = vm1 + (2 -> "two")
  println(vm2 == Map(2 -> "two", 1 -> "one"))

  /**
   * 从上述代码的开头几行可以看出,VectorMap的内容保持了插入的顺序，而从最后一行可以看出，
   *
   * @VectorMap能与其他映射做比较，且这样的比较并不会受到元素次序的影响。
   */

  /**
   * @列表映射(ListMap)
   *
   * 列表映射 将映射表示为一个由 键/值 对组成的链表。
   * 一般而言，对列表映射的操作需要遍历整个列表，因此，对列表映射的操作耗时与映射的规模成正比。
   * @事实上，Scala对于列表映射用得很少，因为标准的不可变映射几乎总是比列表映射更快。
   * @唯一可能有区别的场景是当映射因为某种原因需要经常访问列表中的首个元素时，其频率远高于访问其他元素的频率。
   */
  val map = collection.immutable.ListMap(1 -> "one", 2 -> "two")
  println(map.get(2))

  


}
