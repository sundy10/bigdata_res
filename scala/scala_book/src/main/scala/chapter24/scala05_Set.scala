package chapter24

import scala.collection.mutable.{ArrayBuffer, ListBuffer}

object scala05_Set extends App {

  /**
   * 24.5 集
   *
   * Set是没有重复元素的lterable特质。对集的操作汇总在表24.5.png(一般的集)、表24.6.png(不可变集)和表24.7(可变集)中。
   *
   * 不可变集提供了通过返回新的集来添加或移除元素的方法（见表24.6)。
   *
   * 可变集拥有添加、移除或更新元素的方法（见表24.7)。
   */

  //一般的集的 二元操作
  println(Set(1, 2, 3) & Set(1, 2, 4))
  println(Set(1, 2, 3) intersect Set(1, 2))

  println(Set(1, 2, 3) | Set(1, 2, 4))
  println(Set(1, 2, 3) union Set(1, 2, 4))

  println(Set(1, 2, 3) &~ Set(1, 2, 4)) //这里为调用的Set对象的差集
  println(Set(1, 2, 4) diff Set(1, 2, 3, 100, 200, 300))


  /**
   * @测试
   *
   * contains、apply和subsetOf方法。
   * contains方法表示当前集是否包含某个给定的元素。
   * 集的apply方法等同于contains方法，因此set(elem)相当于set.contains(elem)。
   * 这意味着集可以被用作测试函数，并对那些它包含的元素返回true。例如:
   */
  val fruit = Set("apple", "orange", "peach", "banana")
  println(fruit("peach"))
  println(fruit("potato"))

  /**
   * @添加
   *
   * +    (别名incl)和++（别名concat)方法可以将一个或多个元素添加到集，并交出新的集。
   */

  /**
   * @移除
   *
   * - (别名excl）和 --(别名removedAll）方法可以从集中移除一个或多个元素，并交出新的集。
   */

  /**
   * @集操作
   *
   * 交集、并集和差集。这些集操作有两种形式:字母的和符号的。
   * 字母的版本有intersect、union和diff，而符号的版本有&、|和&~。Set
   * 从lterable特质继承的++方法可以被看作union或 | 方法的另一个别名，
   * 只不过++方法接收lterable特质作为入参，而union和|方法的入参是集。
   */

  /**
   * s+= elem这个操作以副作用的方式将elem添加到集s中，并返回变更后的集。
   * 除+=和-=方法外，还有批量操作方法++=和--=，这些操作方法将添加或移除lterable、Iterator给出的所有元素。
   */

  /**
   * +=和-=这样的方法名意味着我们可以对可变集和不可变集使用非常相似的代码来处理。参考下面这段用到不可变集s的编译器会话:
   */
  var s = Set(1, 2, 3)
  s += 4
  s -= 2

  /**
   * 在这个例子中，我们对一个类型为immutable.Set的var使用了+=和-=方法。
   * 第3章的第10步曾经介绍过，形s += 4的语句是s=s+ 4的简写形式。
   * 因此这段代码会调用集s的+方法，然后将结果重新赋值给变量s。接下来再看看对可变集的类似交互:
   */
  val s1 = collection.mutable.Set(1, 2, 3)
  s1 += 4

  /**
   * 最终的效果与前一次交互非常相似:从Set(1, 2,3)开始，最后得到一个 Set(1,3,4)。
   * 不过，虽然语句与之前的语句看上去一样，但是它们做的事情并不相同。这次的s += 4调用的是可变集s的+=方法，当场修改了集的内容。
   * 同理，这次的s -= 2调用的是同一个集的-=方法。
   */

  /**
   * 通过比较这两次交互，我们可以看到一个重要的原则:通常可以用一个被保存为var的不可变集合替换一个被保存为val的可变集合，或者反过来。
   *
   * @只要没有指向这些集合的别名让你可以观测到它到底是当场修改的还是返回了新的集合，这样做就是可行的。
   */

  /**
   * 可变集还提供了add和remove方法作为+=及-=方法的变种。区别在于 add 和 remove 方法返回的是表示该操作是否让集发生了改变的布尔值结果。
   */

  /**
   * @目前，可变集的默认实现使用了哈希表来保存集的元素。不可变集的默认实现使用了一种可以与集的元素数量相适配的底层表示。
   * @空集被表示为单个对象。而4个元素以内的集由单个以字段保存所有元素的对象表示。
   * @超出4个元素的不可变集实现为经过压缩的 哈希数组映射的前缀树 (compressed hash-array mapped prefix-tree)。
   */

  /**
   * @上述实现选择带来的影响就是，对4个元素以内的小型集而言，不可变集比可变集更加紧凑，也更加高效。
   * @因此，如果你预期用到的集比较小，则尽量用不可变集。
   */

}
