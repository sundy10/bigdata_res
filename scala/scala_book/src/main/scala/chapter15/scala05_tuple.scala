package chapter15

object scala05_tuple extends App {

  /**
   * 15.5 元组
   *
   * 就像我们在第3章第9步描述的那样，一个元组可以将一组固定个数的条目组合在一起，作为整体进行传递。
   * 不同于数组或列表，元组可以持有不同类型的对象。下面是一个同时持有整数、字符串和控制台对象的元组:
   */
  (1,"hello","Console")

  /**
   * 元组可以帮我们省去定义那些简单的主要承载数据的类的麻烦。
   * 虽然定义类本身已经足够简单，但是这 的确也是工作量，而且有时候除了定义一下，也没有其他的意义。
   * 有了元组，我们就不再需要给类选择一个名称、选择一个作用域、选择成员的名称等。
   * 如果我们的类只是简单地持有一个整数和一个字符串，则定义一个名称为AnIntegerAndAString的类并不会让代码变得更清晰。
   *
   * @由于元组可以将不同类型的对象组合起来，因此它并不继承自lterable。
   * 如果只需要将一个整数和一个字符串放在一起，则我们需要的是一个元组，而不是列表或数组。
   * @元组的一个常见的应用场景是从方法中返回多个值。下面是一个在集合中查找最长单词，同时返回下标的方法:
   */
  def longestWord(words:Array[String]):(String,Int)=
    var word =words(0)
    var idx =0
    for i<- 1 until words.length do
      if words(i).length > word.length then
        word = words(i)
        idx = i
    (word,idx)

  val longest: (String, Int) = longestWord("The quick brown fox".split(" "))
  println(longest)


  /**
   * 这里的longestWord函数用于计算两项:数组中最长的单词word和这个单词在数组中的下标idx。
   * 为了尽可能保持简单，这个函数假设列表中至少有一个单词，且选择最长单词中最先出现的那一个。
   * 一旦这个函数选定了要返回的单词和下标，就用元组语法(word, idx)同时返回这两个值。
   *
   * 要访问元组的元素，可以用圆括号和从0开始的下标，其结果会拥有正确的类型。例如:
   */
  longest._1
  longest(0)
  //不仅如此，还可以将元组的元素分别赋值给不同的变量，就像这样:(这个语法实际上是模式匹配的—─个特例，具体细节可参考13.7节。)
  val (word,idx) =longest
  val word1,idx1 =longest

  /**
   * 这样的语法对相同的表达式给出了多重定义(multipledefinitions)。每个变量都通过对等号右侧的表达式求值来初始化。
   * 在本例中，对右侧表达式求值得到元组这个细节并不重要。两个变量都被完整地赋予了元组的值。
   * 更多 多重定义的例子可以参考第16章
   */

  /**
   * @需要注意的是，元组用起来太容易，以致我们可能会过度使用它。
   * @当我们对数据的要求仅仅是类似“一个A和一个B”的时候，元组很适用。
   * @不过，一旦这个组合有某种具体的含义，或者我们想给这个组合添加方法的时候，最好还是单独创建一个类。
   * @举例来说，不建议用三元组来表示年、月、日的组合，建议用Date类。这样意图更清晰,对读者更友好，也让编译器和语言有机会帮助我们发现程序错误。
   */

  /**
   * 15.6 结语
   *
   * 本章给出了Scala集合类库的概览，介绍了类库中最重要的类和特质。有了这个作为基础，你应该能够高效地使用Scala集合，并且知道在需要时如何查询Scaladoc文档以获取更多信息。
   * 关于Scala集合的更多信息，可以参考第3章和第24章。在下一章，我们将注意力从Scala类库转向语言本身，探讨Scala对可变对象的支持。
   */


}
