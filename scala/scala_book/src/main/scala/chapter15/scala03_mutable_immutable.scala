package chapter15

object scala03_mutable_immutable extends App {

  /**
   * 15.3 在可变和不可变集合之间选择
   *
   * 对于某些问题，可变集合更适用;而对于另一些问题，不可变集合更适用。
   *
   * @如果拿不定主意，则最好从一个不可变集合开始，这是因为如果事后需要再做调整，那么与可变集合比起来，不可变集合更容易推敲。
   *
   * 同样地，有时我们也可以反过来看。如果发现某些使用了可变集合的代码开始变得复杂和难以理解，也可以考虑是不是换成不可变集合会有所帮助。
   * @尤其是当我们发现经常需要担心在正确的地方对可变集合做复制，或者花大量的时间思考谁“拥有”或“包含”某个可变集合时，应当考虑将某些集合换成不可变的版本。
   * @除了更容易推敲，在元素不多的情况下，不可变集合通常还可以比可变集合存储得更紧凑。
   * @举例来说，一个空的可变映射按照默认的HashMap实现会占据80字节，且每增加一个条目需要额外的16字节。一个空的不可变Map只是单个对象，可以被所有的引用共享，所以引用它本质上只需要花费一个指针字段。
   * @不仅如此,Scala集合类库目前的不可变的映射和集的单个对象最多可以存储4个条目，根据条目数的不同，通常占据16～40字节。(这里的“单个对象”指的是Set1到Set4(以及Map1至Map4)的实例,如表15.3和表15.4所示。)
   * @因此，对小型的映射和集而言，不可变的版本比可变的版本紧凑得多。由于在实际使用中很多集合都很小，因此采用不可变的版本可以节约大量的空间，带来重要的性能优势。
   *
   * 为了让不可变集合转换到可变集合(或者反过来)更容易，Scala提供了一些语法糖。
   * @虽然不可变的集和映射并不真正支持+=方法，
   * @但是Scala提供了一个变通的解读:只要看到a+=b而a并不支持名称为+=的方法,Scala就会尝试将它解读为a=a+b。
   * 不过，如果我们将people声明为var而不是val，这个集合就能用=方法来“更新”，尽管它是不可变的。首先,一个新的集合被创建出来,然后people将被重新赋值指向新的集合:
   */

  var people = Set("Nancy", "Jane")
  people += "Bob"
  println(people)

  /**
   * 在这一系列语句之后，变量people指向了新的不可变集合，包含添加的字符串"Bob"。
   * 同样的理念适用于任何以=结尾的方法，并不仅仅是+=方法。
   * 下面是将相同的语法规则应用于-=操作符的例子，可将某个元素从集里移除;
   * 以及应用于++=操作符的例子，可将一组元素添加到集里:
   */
  people -= "Jane"
  people ++= List("Tom", "Harry")
  println(people)

  /**
   * 要弄清楚为什么这样做是有用的，我们再回过头看看1.1节里那个Map的例子:
   */
  var capital = Map("US" -> "Washington", "France" -> "Paris")
  capital += ("Japan" -> "Tokyo")
  println(capital("France"))

  /**
   * 这段代码使用了不可变集合。如果想使用可变集合，则只需要引入可变版本的映射即可，这样就覆盖了对不可变映射的默认引用:
   */
  import scala.collection.mutable.Map
  var capital1 = Map("US" -> "Washington", "France" -> "Paris")
  capital1 += ("Japan" -> "Tokyo")
  println(capital1("France"))

  /**
   * 并不是所有的例子都这么容易转换，不过对那些以等号结尾的方法的特殊处理通常会减少需要修改的代码量。
   *
   * 这样的特殊语法不仅适用于集合，而且适用于任何值。参考下面这个浮点数的例子:
   */
  var roughlyPi =3.0
  roughlyPi += 0.1
  roughlyPi += 0.04

  /**
   * @这种展开的效果与Java的赋值操作符（+=、-=、有等)类似，不过更为一般化，因为每个以=结尾的操作符都能被转换。
   */

}
