package chapter08

object scala07_closure extends App {

  /**
   * @8.7闭包
   *
   * 到目前为止，本章所有的函数字面量示例，都只是引用了传入的参数。
   *
   * 例如，在(x:Int)=>x >0中，唯一在函数体x >0中用到的变量是x，即这个函数的唯一参数。不过，也可以引用其他地方定义的变量:
   */

  //val a= (x:Int)=>x+more //more是多少呢 ?

  /**
   * 这个函数将“more”也作为入参，不过more是从哪里来的?
   *
   * @从这个函数的角度来看，more是一个自由变量 （free variable)，因为函数字面量本身并没有给more赋予任何含义。
   * @相反，x是一个绑定变量 (bound variable)，
   *              因为它在该函数的上下文里有明确的含义:它被定义为该函数的唯一参数，一个Int。
   *              如果单独使用这个函数字面量,且并没有在任何处于作用域内的地方定义more，则编译器将报错
   *
   *              另一方面，只要能找到名称为more的变量，同样的函数字面量就能正常工作:
   */

  var more = 1
  val addMore = (x: Int) => x + more
  println(addMore(10))

  /**
   * @概念
   * 运行时从这个函数字面量创建出来的函数值（对象）被称作闭包(closure)。
   * @该名称源于“捕获”其自由变量从而“闭合”该函数字面量的动作。
   * @没有自由变量的函数字面量，如(x:Int)=>x+1，被称作闭合语 (closed term)，
   *
   *                                    这里的语（term)指的是一段源代码。因此，严格来说，运行时从这个函数字面量创建出来的函数值并不是一个闭包，因为(x:Int)=> x＋1按照目前这个写法来说已经是闭合的了。
   *                                    而对于运行时从任何带有自由变量的函数字面量，如(x: Int) =>x + more，创建的函数值，按照定义，要求捕获它的自由变量more的绑定。
   *                                    相应的函数值结果（包含指向被捕获的more变量的引用)就被称作闭包，因为函数值是通过闭合这个开放语（ open term)的动作产生的。
   */

  /**
   * 这个例子带来一个问题:
   *
   * @如果more在创建闭包以后被改变会发生什么呢?
   * @在Scala中，答案是闭包能够看到这个改变。参考下面的例子:
   */

  more = 9999
  println(addMore(10))


  /**
   * @很符合直觉的是，Scala的闭包捕获的是变量本身，而不是变量引用的值。
   * 正如前面示例所展示的，为(x: Int) => x + more创建的闭包能够看到闭包外对more的修改。
   * @反过来也是成立的:闭包对捕获的变量的修改也能在闭包外被看到。参考下面的例子:
   *
   * Java则不同，Java的lambda表达式并不允许访问外围作用域的可修改变量，除非这些变量是final或实效final的，所以本质上java lambda表达式内捕获变量和捕获它的值之间并没有差别。
   */

  val someNumbers = List(-11, -10, -5, 0, 5, 10)
  var sum = 0
  someNumbers.foreach(sum += _)
  println(sum)

  /**
   * 上面这个例子通过绕圈的方式来对List中的数字求和。sum这个变量位于函数字面量sum +=_的外围作用域，由这个函数将数字加给sum。
   * 虽然运行时是这个闭包对sum进行的修改，但是最终的结果-11仍然能被闭包外部看到。
   */

  /**
   * 那么，如果一个闭包访问了某个随着程序运行会产生多个副本的变量会如何呢?
   *
   * 例如，如果一个闭包使用了某个函数的局部变量，而这个函数又被调用了多次，会怎么样呢?
   * 闭包每次访问到的是这个变量的哪一个实例呢?
   */

  /**
   * 只有一个答案
   * 与Scala其他组或部分是一致的:
   *
   * @闭包引用的实例是在闭包被创建时活跃的那一个。参考下面这个创建并返回“增加”闭包的函数:
   */

  def makeIncreaser(more: Int): Int => Int = (x: Int) => x + more //该方法体返回 (Int)=>Int

  /**
   * 每调用一次该函数，就会创建一个新的闭包。每个闭包都会访问那个在创建它时活跃的变量more。
   */

  val inc1=makeIncreaser(1)
  val inc9999= makeIncreaser(9999)

  /**
   * 当你调用makelncreaser(1)时，一个捕获了more的绑定值1的闭包就被创建并返回出来。
   * 同理，当你调用makeIncreaser(9999)时，返回的是一个捕获了more的绑定值9999的闭包。
   *
   * 当你将这些闭包应用到入参（本例中只有一个必选参数x）上时，其返回结果取决于闭包创建时more的定义。
   */
  println(inc1(10))
  println(inc9999(10))

  /**
   * 这里的more是某次方法调用的入参，而方法已经返回了，不过这并没有影响。
   * @Scala编译器会重新组织和安排，让被捕获的参数在堆上继续存活。
   * @这样的安排都是由编译器自动帮我们完成的，你并不需要关心。看到喜欢的变量，你只管捕获就好———val、var、参数，都没问题。
   *
   * @不过，当你采用函数式编程风格时，只会捕获val。在并发场景下，如果你使用指令式编程风格来捕获var,则会遇到因对共享可变状态的非同步访问而引起的并发bug。
   */

}
