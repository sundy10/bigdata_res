package chapter08

object scala08_special_function_call extends App {

  /**
   * 8.8 特殊的函数调用形式
   *
   * 你会遇到的大多数函数和函数调用都像你在本章到目前为止看到的那样:函数会有固定数量的形参，在调用时也会有相同数量的实参，而这些实参出现的顺序也会与形参出现的顺序相同。
   *
   * 由于函数调用在Scala编程中的核心地位，因此对于某些特殊的需求，
   *
   * @一些特殊形式的函数定义和调用方式也被加入语言中。
   * @Scala支持重复参数、带名称的参数和默认参数。
   */

  /**
   * @1.重复参数
   *
   * Scala允许你标识出函数的最后一个参数可以被重复。
   * 这让我们可以对函数传入一个可变长度的参数列表。
   * 要表示这样一个重复参数，需要在参数的类型之后加上一个星号(*)。例如:
   */

  def echo(args: String*) = for arg <- args do println(arg)

  echo()
  echo("hello!", "world!", "你好!")

  /**
   * 在函数内部，这个重复参数的类型是一个声明参数类型的Seq。
   * 因此，在echo函数内部，“String*”的类型其实是Seq[String]。
   * 尽管如此，如果你有一个合适类型的序列，并尝试将它作为重复参数传入时，将得到一个编译错误
   *
   * @要完成这样的操作，需要在序列实参的后面加上一个*符号
   *
   * 这种表示法可以告诉编译器将seq的每个元素作为参数传递给echo，而不是将所有元素放在一起作为单个实参传入。
   */
  val seq = Seq("What's", "up", "doc?")
  echo(seq *)

  /**
   * @2.带名称的参数
   *
   * 在一个普通的函数调用中，实参是根据被调用的函数的参数定义，逐个匹配起来的
   */
  def speed(distance: Float = 100.0, time: Float) = distance / time

  println(speed(100, 10))

  /**
   * 带名称的参数让你可以用不同的顺序将参数传递给函数，其语法是简单地在每个实参前加上参数名和等号。
   */
  println(speed(distance = 1000, time = 10))

  /**
   * 我们还可以混用按位置和带名称的参数。在这种情况下，按位置的参数需要被放在前面。带名称的参数通常与默认参数值一起使用。
   */
  println(speed(time = 100))

  /**
   * @3.默认参数
   *
   * Scala允许给函数参数指定默认值。这些有默认值的参数可以不出现在函数调用中，对应的参数将会被填充为默认值。
   */

  import chapter06.scala05_Extension_methods.*

  println(Rational(100))
  println(Rational(42, 83))

  /**
   * 默认参数与带名称的参数被放在一起时尤为有用。在示例8.4中，point函数有两个可选参数，即x和y。两个参数的默认值都是0。
   * 通过带名称的参数，这两个参数中的任何一个都可以被显式给出，而另一个将被填充为默认值。要显式地给出x，且让y保持默认值
   */
  def point(x: Int = 0, y: Int = 0) = (x, y)

  println(point(x=42))
  println(point(y=1000))

}
