package chapter23

object scala01_why_use_typeclass extends App{

  /**
   * 23.1为什么要用类型族
   *
   * 在Scala的上下文中，“类型族”(typeclass)这个词可能不太好懂,因为虽然这个词里的类型(type）指的是Scala的类型(type) ,
   * 但是族(class）并不是Scala的类(class)。typeclass这个词里的class是常规英语中的含义，用来表示一组事物或事物的合集。
   * 因此，类型族指的就是一组类型或类型的合集。
   */

  /**
   * 21.4节曾经提到过，类型族支持特定目的多态，意思是函数可以用于特定的可被枚举的一组类型。
   * 任何将这个函数用于这组可被枚举的类型之外的类型的尝试都无法通过编译。
   * 举例来说，特定目的多态这个概念最早在很多编程语言中被用来描述
   * 诸如 + 或 - 的操作符能够被用于特定的类型而不能被用于其他类型。
   *
   * @在Scala中，我们是通过重载方法来实现的。例，scala.Int的接口包含了7个名称为减（(-)的重载的抽象方法:
   *
   *    def -(x:Double):Double
   *    def -(x:Float):Float
   *    def -(x:Long):Long
   *    def -(x:Int):Int
   *    def -(x:Char):Int
   *    def -(x:Short):Int
   *    def -(x:Byte):Int
   *
   * 因此，你可以向Int类的减方法传入这7种特定类型的实例，也可以把这7种类型看作减方法接收的一组（或常规英语中的class)类型。参考图23.1.png。
   */

  /**
   * 在Scala中实现多态的另一种方式是类继承关系。这里有一个使用密封特质来定义一组颜色的例子:
   */
  sealed trait RainbowColor
  class Red extends RainbowColor
  class Orange extends RainbowColor
  class Yellow extends RainbowColor
  class Green extends RainbowColor
  class Blue extends RainbowColor
  class Indigo extends RainbowColor
  class Violet extends RainbowColor

  /**
   * 有了这样的类继承关系，就可以定义一个接收RainbowColor特质作为入参的方法:
   */
  //def paint(rc:RainbowColor):Unit

  /**
   * 由于RainbowColor特质是密封的，因此paint方法只能被传入如图23.2所示的7种类型的入参。
   * 传入任何其他类型的入参都无法通过编译。虽然这种方式可以被看作特定目的多态，但是我们将其称为子类型多态，
   * @这是为了强调一个重要的区别:所有被传入paint方法中的实例的类都必须混入RainbowColor特质，并且满足由此接口带来的任何约束。
   * 对比而言，图23.1中的Int类的减(-）方法所接收的参数类型并不需要满足除Scala的顶层类型Any之外的任何公共接口的约束。
   * @简言之，子类型多态针对的是相关的（related）类型，而特定目的多态（比如重载和类型族）针对的是不相关的（unrelated）类型。
   */

  /**
   * 由于接口的约束，子类型多态在类继承关系能够围绕单个概念定义一小组类型时最适用。
   * 密封类继承关系和枚举都是很好的例子。在这些自包含的成组类型中，确保接口的兼容性是直截了当的。
   * 子类型多态也能用于对那些更大的、非密封的，但聚焦在单个概念上的类继承关系建模。
   * Scala的集合类库就是这样的例子。不过，如果要针对某个应用广泛的特定行为（但除此行为之外毫不相关)的类型进行建模（如序列化或排序)，
   *  则子类型多态的方案就显得有些麻烦了。
   */

  /**
   * 以Scala的Ordered特质为例，这是一个用子类型对次序建模的特质。
   * 如11.2节和18.7节所示，如果你将Ordered特质混入某个类并实现compare方法，就继承了<、>、=和>=方法。
   * 另外，你还可以用Ordered特质作为上界来定义排序方法，如示例18.11 （406页）中的orderedMergeSort方法。
   *
   * 这种方案的局限在于，任何你想要传给orderedMergeSort方法的参数类型T都必须混入Ordered[T]并满足Ordered[T]的接口约束。
   * 因此，一个潜在的问题是，你打算混入Ordered特质的类已经定义了重名的方法，或者在接口契约上与Ordered特质相冲突。
   * 另一个潜在的问题是型变冲突。假设你想要对19.4节的Hope类型混入Ordered特质，那么你可能会希望通过将Sad对象排序为最小的Hope值，
   * 然后将Glad对象的次序定义为基于它包含的对象排序的方式来实现compare方法。不幸的是，编译器会拒绝你的这个方案，因为Hope类型在类型参数上是协变的，而Ordered特质是不变的:
   *
   * class Hope[+T <:Ordered[T] ] extends Ordered[Hope[T]]
   *
   * 因此，子类型多态的一个潜在的问题是已经存在的接口可能是不兼容的。
   * 另一个更常见的问题是“你无法修改”已经存在的兼容接口。例如，你无法使用示例18.11的orderedMergeSort方法对List[Int]排序，
   * 因为Int并非扩展自Ordered[Int]，而你无法改变这个事实。
   * 在实践中，用子类型来完成那些应用在很多本不相关的类型上的通用概念的主要困难，来自那些类型通常都被定义在你无法修改的类库里。
   */

  /**
   * 类型族通过定义一个聚焦在这个通用概念上的单独的(separate）类型关系来解决这个问题，
   * 并使用类型参数来给出某个服务接收的类型(提供服务的目标对象)。由于这个单独的类型关系仅聚焦在一个概念上，
   * 如序列化或排序，因此确保接口兼容就变得十分直截了当。
   * 由于类型族实例用类型参数来表示其提供服务的目标类型，因此你不需要改变某个类型来向它提供这项服务。
   * 这样一来，你就可以很容易地针对那些位于你无法修改的类库中的类型  定义类型族上下文参数实例了。
   * (以这种方式使用类型参数被称为全类型多态（universalpolymorphism)。)
   */

  /**
   * 一个不错的例子是Scala的Ordering类型族，它定义了一组专门用于排序的类型关系。
   * 而这组Ordering类型关系是与要排序的类型关系独立开的。
   * 这样一来，即使你不能将Ordered特质混入Hope类型，也可以为Hope类型定义一个Ordering上下文参数实例。
   * 虽然Hope类型归属于一个你无法修改的类库，并且Hope类型和Ordering上下文参数实例在型变上有所不同，前者是协变的而后者是不变的，
   * 但是你仍然可以这样做。示例23.1给出了这样一个实现。
   */

  /**
   * @Ordering类型族是包括了所有定义了Ordering[T]的上下文参数实例的类型T的集合。
   * 标准类库为很多类型，如Int或String，都提供了Ordering上下文参数实例，并将这些类型归类为Ordering类型族的标准成员。
   * 示例23.1给出的hopeOrdering上下文参数实例将形式为Hope[T](针对所有类型T)的类型族成员也添加到Ordering类型族中。
   * 组成Ordering类型族的类型集合如图23.3所示。
   */

  /**
   * @类型族支持特定目的多态，因为你可以编写只能被用于那些存在特定类型族的上下文参数实例的类型的函数。
   * 任何想把这个函数用于不具备所要求的类型族上下文参数实例的类型的尝试都将不能通过编译。
   * 举例来说，你可以对示例21.5 (465页)的msort传入任何List[T]，只要针对类型T定义了Ordering[T]的上下文参数实例即可。
   * 由于标准类库提供了Ordering[Int]和Ordering[String]的上下文参数实例，因此你可以向msort传入List[Int]和List[String]。
   * 不仅如此，如果你引入示例23.1给出的hopeOrdering上下文参数实例，则还可以向msort传入List[Hope[Int]、List[Hope[String或List[Hope[Hope[Int等。
   * 另一方面，任何向msort传入未定义Ordering上下文参数实例的元素类型的列表的尝试都将不能通过编译。
   */

  /**
   * 总体来说，类型族解决的是那些很难、不方便或不可能把某一类服务打包到该类型的某种类继承关系中的问题。
   * 在实践中，并不是所有你想要提供某种通用服务的类型都能够通过实现某个接口来将它带入某个公共的类继承关系中的。
   * @类型族的方案允许你用独立的另一组类型关系来专门提供这个通用服务。
   */

}
