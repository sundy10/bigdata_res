package chapter12

object scala07_export extends App {

  /**
   * 12.7 导出
   *
   * 在10.11节，我们曾建议你优先选择组合而不是继承，尤其当你的首要目的是代码复用时。
   * 这是最小权力原则(principal of leastpower）的实际应用:组合将组件当作黑盒，而继承则通过重写机制影响组件的内部工作机制。
   * 有时候，继承所隐含的紧耦合是解决具体问题的最佳方案，但当这并不是必需的时，就意味着松耦合的组合是更优的选择。
   *
   * 在大多数主流的面向对象编程语言中，使用继承比使用组合更容易。
   * 比如，在Scala 2中，继承只需要一个extends子句，而组合需要一系列冗长的透传。
   * 因此，大多数面向对象的编程语言都在把程序员推向那些通常更加强大的解决方案。
   *
   * @导出( export）是Scala 3引入的新特性，目标是把这个不平衡的局面扭转过来。
   *      导出可以让组合关系的表达与继承关系的表达一样精简和容易。同时，与extends子句相比，导出也更灵活，因为成员可以被重命名或排除在外。
   *
   *      作为示例，考虑这样的场景，假设你希望构建一个用于表示正整数的类型，则可以像这样定义一个类:
   *      (另外两种规避了装箱动作的方式分别是AnyVal和不透明类型(opaque type)。其中，AnyVal将在17.4节介绍，不透明类型请参考《Scala高级编程》。)
   *
   *      可以为PosInt芙实现一个+方法，让它用起来方便一些。这个+方法只需要转调对应的value的+方法即可:
   */
  case class PosInt(value: Int):
    require(value > 0)

    def +(x: Int): Int = value + x

  /**
   * 这个类允许你在类型层面声明某个整数是正数。不过，如果像这样写的话，则你需要访问value来对相应的Int参数执行算术运算:
   */
  val x = PosInt(88)
  println(x.value + 1)

  /**
   * 有了这个转调方法，就可以直接对PosInt类执行整数的加法而不需要（显式地)访问value了:
   */
  val x1 = PosInt(77)
  println(x1 + 1)

  /**
   * 可以继续实现Int类的所有方法来让PosInt类更方便，但Int类的方法多达100余个。如果你能把PosInt类定义为Int类的子类，就可以使其继承所有这些方法，不需要重新实现。
   * 不过由于Int类是final的，你并不能这样做。这就是PosInt必须用组合和转调而不能用继承的原因。
   *
   * 在Scala 3中，可以用export关键字来标明你希望转调的方法，并由编译器来帮你生成。这里有一个PosInt类的例子，声明了需要转调底层value的相关方法:
   */

  case class PosInt2(value: Int):
    require(value > 0)
    export value.*

  /**
   * 有了这个设计，就可以对PosInt类调用任何直接在Int类中声明的方法:
   */
  val x2 = PosInt2(99)
  println(x2 + 1)
  println(x2 - 1)
  println(x2 / 3)

  /**
   * @导出子句将会对每个导出方法创建被称为导出别名(export alias）
   * @的重载形式的final方法。例如，接收Int参数的+方法在PosInt类中会有如下签名:
   *
   * final def +(x:Int):Int =value + x
   *
   * 对于导出，可以使用所有对引入有效的语法。例如，你可能不打算对PosInt类提供符号形式的位移操作符（<<、>>、>>>) :
   *
   * 那么可以在导出时对这些操作符用as重命名，就像你可以在引入时使用as重命名标识符一样。举例来说:
   */
  case class PostInt3(value: Int):
    require(value > 0)
    export value.{<< as shl, >> as shr, >>> as ushr, *}

  /**
   * 有了这样的导出子句，PosInt类就不再具备符号形式的位移操作符了:
   */
  val x3 = PostInt3(24)
  println(x3 shl 1)
  println(x3 shr 1)
  println(x3 ushr 1)

  /**
   * @也可以用“as_”从一个通配的导出中排除指定的方法，就像从一个通配的引入中排除指定的标识符那样。
   * 例如，由于右移操作符(>>)和无符号右移操作符（>>>）对正整数而言总是产生相同的结果，因此你可能会希望只提供一个右移操作符。为此，你只需要用“>>> as_”将>>>从导出中排除即可，就像这样:
   * 如此一来，就不会创建任何与>>>方法对应的名称或别名了
   */
  case class PostInt4(value:Int):
    require(value>0)
    export value.{<< as shl, >> as shr ,>>> as _,*}

  /**
   * 12.8 结语
   *
   * 在本章，你看到了将程序切分为包的基本语法结构。这给了你简单而实用的模块化功能，让你能够将大量的代码分割成不同的组成部分，从而避免相互冲突和干扰。
   * Scala的包与Java的包十分神似，但也有一些区别，Scala在这方面做得比Java更一致、更通用。
   * 你还看到了一个新的特性，即导出，其目标是让组合在代码复用方面与继承一样便捷。
   *
   * @展望未来，《Scala高级编程》将会介绍一种比切分包更灵活的模块系统。
   * @除了允许你把代码分割成若干命名空间，这样的模块系统还允许我们对模块做参数化处理，以及让这些模块继承彼此。在下一章，我们先把注意力转向样例类和模式匹配。
   */

}
