package chapter18

object scala04_check_type_annotation extends App {

  class Queue[T](private val leading: List[T],
                  private val trailing: List[T]):
    private def mirror =
      if leading.isEmpty then
        new Queue(trailing.reverse, Nil)
      else this

    def head = mirror.leading.head

    def tail =
      val q = mirror
      new Queue(q.leading.tail, q.trailing)

    def enqueue(x: T) =
      new Queue(leading, x :: trailing)


  /**
   * 18.4 检查型变注解
   *
   * 既然你已经看到有一些型变不可靠的例子，那么你可能会想，什么样的类定义需要被拒绝，什么样的类定义能够被接受呢?
   * @到目前为止，所有对类型可靠性的违背都涉及可被重新赋值的字段或数组元素。
   * @相应地，纯函数式实现的队列看上去是协变的。不过，通过如下的例子你会看到，即使没有可被重新赋值的字段，还是有办法能“刻意地做出”不可靠的情况。
   *
   * 要构建这样一个例子，我们先假设示例18.4定义的队列是协变的。然后，创建一个针对元素类型int的队列子类，重写enqueue方法:
   */
//  class StrangeIntQueue extends Queue[Int]:
//    override def enqueue(x: Int) =
//      println(math.sqrt(x))
//      super.enqueue(x)

  /**
   * StrangelntQueue 的enqueue方法会先打印出（整数)入参的平方根，再处理追加操作。
   * 现在，我们可以用两行代码做出一个反例:
   */
//  val x:Queue[Any] = new StrangeIntQueue
//  x.enqueue("abc")

  /**
   * 两行代码中的第一行是合法的，因为StrangeIntQueue是Queue[Int]的子类,并且（假定队列是协变的)Queue[Int]是Queue[Any]的子类型。
   * 第二行也是合法的，因为我们可以追加一个String到Queue[Any]中。
   * 不过，将两行代码结合在一起，最终的效果是对一个字符串执行了求平方根的操作，这完全不合理。
   *
   * @显然，不仅只有可变字段能让协变类型变得不可靠，还有更深层次的问题。
   * @一旦泛型参数类型作为方法参数类型出现，包含这个泛型参数的类或特质就不能以那个类型参数做协变。
   *
   * 对队列而言，enqueue方法违背了这个条件:
   * class Queue[+T]
   *    def enqueue(x: T) ={...}
   *
   *  通过Scala编译器运行上面这样一个修改后的队列类会给出: Iterable1.png
   */

  /**
   * @可被重新赋值的字段是如下规则的特例:用+注解的类型参数不允许用于方法参数的类型。
   * @正如我们在16.2节提到的，一个可被重新赋值的字段“var x: T”在Scala中被当作getter方法“def x: T”和setter方法“def x_=(y: T)”。
   * @我们看到setter方法有一个参数，其类型为字段类型T。因此这个类型不能是协变的。
   */

  /**
   * @_快速通道
   *
   * 本节剩余部分将描述Scala编译器检查型变注解的机制。如果你暂时对这样的细节不感兴趣，则可以安心地跳到18.5节。
   * @需要理解的最重要的一点是，Scala编译器会检查你添加在类型参数上的任何型变注解。
   * @例如，如果你尝试声明一个类型参数为协变的（添加一个+)，但是可能会引发潜在的运行时错误，则你的程序将无法通过编译。
   */

  /**
   * 为了验证型变注解的正确性，Scala编译器会对类或特质定义中的所有能出现类型参数的点归类为协变的( positive)、逆变的( negative）和不变的（neutral)。
   * 所谓的点（position）指的是类或特质（从现在起，我们将笼统地说“类"）中任何一个可以用类型参数的地方。
   * 例如，每个方法值参数都是这样一个点，因为方法值参数有类型，因此类型参数可以出现在那个点”。
   *
   * 译者注:关于型变检查中的positive-position、negative-position、neutral-position,有“正位置、反位置、中性位置” 和
   * “协变点、逆变点、不变点”两种常见译法，译者从更直观、更贴近实际效果的角度出发采用了后者。
   */

  /**
   * @编译器会检查类的类型参数的每一次使用。用+注解的类型参数只能用在协变点;用-注解的类型参数只能用在逆变点;
   * @而没有型变注解的类型参数可以用在任何能出现类型参数的点，因此这也是唯一的一种能用在不变点的类型参数。
   *
   * @为了对类型参数点进行归类，编译器从类型参数声明开始，逐步深入更深的嵌套层次。
   * @声明该类型参数的类的顶层的点被归类为协变点。更深的嵌套层次默认为与包含它的层次相同，   举例 class A[T]{...}  A[T]为协变点     def append[X](a:Y,b:Array[Z]) 中 Y、Z点的型变与W相同
   *
   * @不过在一些例外情况下归类会发生变化。方法值参数的点被归类为方法外的翻转(flipped)，其中协变点的翻转是逆变点，逆变点的翻转是协变点，而不变点的翻转仍然是不变点
   * @除了方法值参数，当前的归类在方法的类型参数上也会翻转。   举例：def append[X](a:Y,b:Array[Z]) 中Y为值参数  Z为类型参数
   *
   * @归类有时会在类型的类型入参处翻转，如C[Arg]中的Arg，具体取决于相应的类型参数的型变。如果C的类型参数添加了+注解，则归类保持不变;
   * @如果C的类型参数添加了-注解，则当前的归类会翻转;而如果C的类型参数没有型变注解，则当前归类保持不变。
   *
   * 下面来看一个多少有些刻意的例子，考虑下面这个类的归类,若干个点被标上了它们相应的归类   +（协变)或  -(逆变): img_2.png
   */

  /**
   * 类型参数W，以及两个值参数volume和listener都位于逆变点。
   * 我们重点看一下meow的结果类型。第一个Cat[U,T]的入参位于逆变点，因为Cat的首个类型参数T带上了-的注解。
   * 这个入参中的类型U再次出现在了协变点（两次翻转)，而这个入参中的类型T仍然处于逆变点。
   *
   * 从这些讨论中不难看出，要跟踪型变点相当不容易。不过别太担心，Scala编译器会帮助你做这个检查。
   *
   * 一旦归类被计算出来，编译器就会检查每个类型参数只被用在了正确归类的点。在本例中，T只被用在了逆变点，而U只被用在了协变点。因此Cat类是类型正确的。
   */






}
